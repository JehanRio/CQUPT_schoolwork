/**给定N个整数A1, A2, … AN。请你从中选出K个数，使其乘积最大。
请你求出最大的乘积，由于乘积可能超出整型范围，你只需输出乘积除以1000000009的余数。
注意，如果X<0， 我们定义X除以1000000009的余数是负(-X)除以1000000009的余数。
即：0-((0-x) % 1000000009)
【输入格式】
第一行包含两个整数N和K。
以下N行每行一个整数Ai。
对于40%的数据，1 <= K <= N <= 100
对于60%的数据，1 <= K <= 1000
对于100%的数据，1 <= K <= N <= 100000 -100000 <= Ai <= 100000
【输出格式】
一个整数，表示答案。
【输入样例】
5 3
-100000
-10000
2
100000
10000
【输出样例】
999100009
再例如：
【输入样例】
5 3
-100000
-100000
-2
-100000
-100000
【输出样例】
-999999829**/
#include<iostream>
#include<cmath>
using namespace std;
#define mod 1000000009
#define inf 100000
//知识点：dp
//思路： 如果选，那么结果res1 =【在前i-1个数中(下标1~i)，选j-1个数，乘积最大值】* 【第i个数】
//      如果不选，结果res2 = 【在前i-1个数中(下标1~i)，选j个数，乘积最大值】
int n,k;//n个数 选k个数
typedef long long ll;
ll a[10000];// 可能爆内存，调试改小，提交时还原
ll dp[10000][10000];
int main()
{
    cin>>n>>k;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=i;j++)
        {
            dp[i][j]=-inf;// 因为可能涉及负值，直接初始化为负inf
        }
    }
    //dp初始化：
    // 在1~i个数中，选1个数相乘最大，最大乘积就是选1~i中最大的数
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)
        {
            dp[i][1]=max(dp[i][1],a[j]);
        }
    }
    // 在前i个数中选i个，直接i个数乘起来 
    for(int i=1;i<=n;i++)
    {
        ll sum=1;
        for(int j=1;j<=i;j++)
            sum*=a[j];
        dp[i][i]=sum;
    }

    // 因为第二行dp[2][2]已经确定，直接i=3开始
    for(int i=3;i<=n;i++)
    {
        for(int j=2;j<i;j++)//画dp状态转移图
        {
            ll res1=dp[i-1][j-1]*a[i];//如果选，那么结果res1 =【在前i-1个数中(下标1~i)，选j-1个数，乘积最大值】* 【第i个数】
            ll res2=dp[i-1][j];         //如果不选，结果res2 = 【在前i-1个数中(下标1~i)，选j个数，乘积最大值】
            dp[i][j]=max(res1,res2);
        }
    }
    cout<<dp[n][k]%mod;
    return 0;
}