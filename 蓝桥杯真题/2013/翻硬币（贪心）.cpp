/*小明正在玩一个“翻硬币”的游戏。桌上放着排成一排的若干硬币。我们用*表示正面，用o表示反面（是小写字母，不是零），比如可能情形是**oo***oooo，
如果同时翻转左边的两个硬币，则变为oooo***oooo。现在小明的问题是：如果已知了初始状态和要达到的目标状态，
每次只能同时翻转相邻的两个硬币，那么对特定的局面，最少要翻动多少次呢？
我们约定：把翻动相邻的两个硬币叫做一步操作，要求：
程序输入：两行等长字符串，分别表示初始状态和要达到的目标状态，每行长度<1000
程序输出：一个整数，表示最小操作步数。
例如，用户输入：
**********
o****o****
程序应该输出：5
再例如，用户输入：
*o**o***o***
*o***o**o***
程序应该输出：1
*/
#include<iostream>
#include<string>
using namespace std;
int main()
{
    string s1,s2;
    cin>>s1>>s2;
    int ans=0;
    int len=s1.size();
    for(int i=0;i<len;i++)
    {
        if(s1[i]!=s2[i])
        {
            if(s1[i+1]=='*')
                s1[i+1]='o';
            else s1[i+1]='*';
            ans++;
        }
        
    }
    cout<<ans;
    return 0;
}